import { useEffect, useRef, useCallback } from 'react';
import * as fabric from 'fabric';

interface UseFabricCanvasOptions {
  width: number;
  height: number;
  backgroundColor?: string;
  onPathCreated?: (path: fabric.Path) => void;
  onObjectAdded?: (object: fabric.FabricObject) => void;
}

export function useFabricCanvas(options: UseFabricCanvasOptions) {
  const canvasElementRef = useRef<HTMLCanvasElement>(null);
  const fabricCanvasRef = useRef<fabric.Canvas | null>(null);
  const isInitializedRef = useRef(false);
  const onPathCreatedRef = useRef(options.onPathCreated);
  const onObjectAddedRef = useRef(options.onObjectAdded);

  // Êõ¥Êñ∞ÂõûË∞ÉÂáΩÊï∞ÂºïÁî®
  useEffect(() => {
    onPathCreatedRef.current = options.onPathCreated;
    onObjectAddedRef.current = options.onObjectAdded;
  }, [options.onPathCreated, options.onObjectAdded]);

  // ÂàùÂßãÂåñeffect
  useEffect(() => {
    if (!canvasElementRef.current || isInitializedRef.current) {
      return;
    }

    console.log('üé® useFabricCanvas: ÂºÄÂßãÂàùÂßãÂåñ');

    let canvas: fabric.Canvas;

    try {
      canvas = new fabric.Canvas(canvasElementRef.current, {
        width: options.width,
        height: options.height,
        backgroundColor: options.backgroundColor || '#ffffff',
        preserveObjectStacking: true,
        renderOnAddRemove: true,
        stateful: true,
        allowTouchScrolling: false,
        enableRetinaScaling: true,
        imageSmoothingEnabled: false
      });

      fabricCanvasRef.current = canvas;
      isInitializedRef.current = true;

      // ÈÖçÁΩÆÁªòÂõæÊ®°Âºè
      canvas.isDrawingMode = true;
      canvas.selection = false;

      const brush = new fabric.PencilBrush(canvas);
      brush.color = '#000000';
      brush.width = 5;
      brush.limitedToCanvasSize = true;
      canvas.freeDrawingBrush = brush;

      // ‰∫ã‰ª∂Â§ÑÁêÜ
      const handlePathCreated = (e: any) => {
        console.log('useFabricCanvas: Ë∑ØÂæÑÂàõÂª∫', e.path);
        
        if (e && e.path) {
          // Á°Æ‰øùË∑ØÂæÑÂ±ûÊÄßÊ≠£Á°ÆËÆæÁΩÆÔºåÁâπÂà´ÊòØÈ¢úËâ≤
          const currentBrush = canvas.freeDrawingBrush;
          e.path.set({
            selectable: false,
            evented: false,
            stroke: currentBrush?.color || '#000000',
            strokeWidth: currentBrush?.width || 5
          });
          
          console.log('Ë∑ØÂæÑÈ¢úËâ≤ËÆæÁΩÆ‰∏∫:', currentBrush?.color);
          
          onPathCreatedRef.current?.(e.path);
        }
        
        // Âº∫Âà∂Ê∏≤Êüì
        requestAnimationFrame(() => {
          canvas.renderAll();
        });
      };

      const handleObjectAdded = (e: any) => {
        console.log('useFabricCanvas: ÂØπË±°Ê∑ªÂä†', e.target);
        if (e && e.target) {
          onObjectAddedRef.current?.(e.target);
        }
        
        // Âº∫Âà∂Ê∏≤Êüì
        requestAnimationFrame(() => {
          canvas.renderAll();
        });
      };

      // ÁªëÂÆö‰∫ã‰ª∂
      canvas.on('path:created', handlePathCreated);
      canvas.on('object:added', handleObjectAdded);

      console.log('‚úÖ useFabricCanvas: ÂàùÂßãÂåñÂÆåÊàê');

      // Ê∏ÖÁêÜÂáΩÊï∞
      return () => {
        console.log('üßπ useFabricCanvas: Ê∏ÖÁêÜÁîªÂ∏É');
        if (fabricCanvasRef.current) {
          fabricCanvasRef.current.off('path:created', handlePathCreated);
          fabricCanvasRef.current.off('object:added', handleObjectAdded);
          fabricCanvasRef.current.dispose();
          fabricCanvasRef.current = null;
        }
        isInitializedRef.current = false;
      };

    } catch (error) {
      console.error('‚ùå useFabricCanvas: ÂàùÂßãÂåñÂ§±Ë¥•', error);
      isInitializedRef.current = false;
    }
  }, [options.width, options.height, options.backgroundColor])

  // Êõ¥Êñ∞ÁîªÁ¨îÂ±ûÊÄß
  const updateBrush = useCallback((color: string, width: number, isEraser = false) => {
    const canvas = fabricCanvasRef.current;
    if (!canvas || !isInitializedRef.current) return;

    console.log('useFabricCanvas: Êõ¥Êñ∞ÁîªÁ¨î', { color, width, isEraser });

    canvas.isDrawingMode = true;
    canvas.selection = false;

    // ÂàõÂª∫ÁîªÁ¨î
    const brush = new fabric.PencilBrush(canvas);
    
    if (isEraser) {
      // Ê©°ÁöÆÊì¶Ê®°ÂºèÔºöËÆæÁΩÆ‰∏∫ËÉåÊôØËâ≤Âπ∂ÂêØÁî®ÁâπÊÆäÊ®°Âºè
      brush.color = options.backgroundColor || '#ffffff';
      brush.width = width;
      // Ê†áËÆ∞‰∏∫Ê©°ÁöÆÊì¶Ê®°ÂºèÔºàÂèØÁî®‰∫éÂêéÁª≠ÁöÑÁâπÊÆäÂ§ÑÁêÜÔºâ
      (brush as any).isEraser = true;
    } else {
      // ÁªòÂà∂Ê®°ÂºèÔºö‰ΩøÁî®Áî®Êà∑ÈÄâÊã©ÁöÑÈ¢úËâ≤
      brush.color = color;
      brush.width = width;
      (brush as any).isEraser = false;
    }

    brush.limitedToCanvasSize = true;
    canvas.freeDrawingBrush = brush;
    
    console.log('ÁîªÁ¨îÊõ¥Êñ∞ÂÆåÊàê:', { 
      type: isEraser ? 'Eraser' : 'Pencil',
      color: brush.color, 
      width: brush.width 
    });
  }, [options.backgroundColor]);

  // ËÆæÁΩÆÈÄâÊã©Ê®°Âºè
  const setSelectMode = useCallback(() => {
    const canvas = fabricCanvasRef.current;
    if (!canvas || !isInitializedRef.current) return;

    canvas.isDrawingMode = false;
    canvas.selection = true;
  }, []);

  // Ê∏ÖÁ©∫ÁîªÂ∏É
  const clearCanvas = useCallback(() => {
    const canvas = fabricCanvasRef.current;
    if (!canvas || !isInitializedRef.current) return;

    canvas.clear();
    canvas.backgroundColor = options.backgroundColor || '#ffffff';
    canvas.renderAll();
  }, [options.backgroundColor]);

  // Ëé∑ÂèñÁîªÂ∏ÉJSONÊï∞ÊçÆ
  const getCanvasData = useCallback(() => {
    const canvas = fabricCanvasRef.current;
    if (!canvas || !isInitializedRef.current) return null;

    return canvas.toJSON();
  }, []);

  // Ëé∑ÂèñÁîªÂ∏ÉÂõæÁâáÊï∞ÊçÆ (Base64) - ‰øÆÂ§çÂºÇÊ≠•Ê∏≤ÊüìÈóÆÈ¢ò
  const getCanvasImage = useCallback((format: string = 'png', quality: number = 0.8) => {
    const canvas = fabricCanvasRef.current;
    if (!canvas || !isInitializedRef.current) {
      console.log('‚ùå getCanvasImage: CanvasÊú™ÂàùÂßãÂåñÊàñ‰∏çÂ≠òÂú®');
      return null;
    }

    // Ê£ÄÊü•ÁîªÂ∏ÉÊòØÂê¶ÊúâÂÜÖÂÆπ
    const objects = canvas.getObjects();
    if (objects.length === 0) {
      console.log('‚ùå getCanvasImage: ÁîªÂ∏É‰∏∫Á©∫ÔºåÊ≤°ÊúâÂØπË±°');
      return null;
    }

    console.log('üé® getCanvasImage: ÂºÄÂßãÂØºÂá∫ÁîªÂ∏ÉÂõæÂÉèÔºåÂØπË±°Êï∞Èáè:', objects.length);

    // üîë ÂÖ≥ÈîÆ‰øÆÂ§çÔºöÂº∫Âà∂ÂêåÊ≠•Ê∏≤ÊüìÂÜçÂØºÂá∫
    canvas.renderAll();

    // ËÆ°ÁÆóÂêàÈÄÇÁöÑÁº©ÊîæÊØî‰æãÔºåÁ°Æ‰øùÂõæÁâá‰∏çË∂ÖËøá1024x1024
    const canvasWidth = canvas.getWidth();
    const canvasHeight = canvas.getHeight();
    const maxDimension = 1024;
    const scale = Math.min(maxDimension / canvasWidth, maxDimension / canvasHeight, 1);

    console.log('üìê getCanvasImage: ÁîªÂ∏ÉÂ∞∫ÂØ∏:', { width: canvasWidth, height: canvasHeight, scale });

    const dataURL = canvas.toDataURL({
      format: format as 'png' | 'jpeg',
      quality: Math.min(quality, 0.8), // ÈôêÂà∂Ë¥®ÈáèÈÅøÂÖçËøáÂ§ßÊñá‰ª∂
      multiplier: scale // ‰ΩøÁî®ËÆ°ÁÆóÁöÑÁº©ÊîæÊØî‰æã
    });

    if (dataURL && dataURL.length > 100) {
      console.log('‚úÖ getCanvasImage: ÊàêÂäüÂØºÂá∫ÔºåÊï∞ÊçÆÈïøÂ∫¶:', dataURL.length, 'Ââç50Â≠óÁ¨¶:', dataURL.substring(0, 50));
    } else {
      console.log('‚ùå getCanvasImage: ÂØºÂá∫Â§±Ë¥•ÊàñÊï∞ÊçÆÂºÇÂ∏∏:', dataURL);
    }

    return dataURL;
  }, []);

  // Ê£ÄÊü•ÁîªÂ∏ÉÊòØÂê¶ÊúâÂÜÖÂÆπ
  const hasCanvasContent = useCallback(() => {
    const canvas = fabricCanvasRef.current;
    if (!canvas || !isInitializedRef.current) {
      console.log('‚ùå hasCanvasContent: CanvasÊú™ÂàùÂßãÂåñ');
      return false;
    }

    const objects = canvas.getObjects();
    const hasContent = objects.length > 0;
    console.log('üîç hasCanvasContent: ÂØπË±°Êï∞Èáè:', objects.length, 'ÊúâÂÜÖÂÆπ:', hasContent);
    return hasContent;
  }, []);

  // === ÂØºÂá∫Â∑•ÂÖ∑ÔºöÂßøÊÄÅPNGÔºàÈÄèÊòéÔºâ‰∏éÈÅÆÁΩ©PNGÔºàÈªëÁôΩÔºâ ===
  const exportPoseImage = useCallback(() => {
    const canvas = fabricCanvasRef.current;
    if (!canvas || !isInitializedRef.current) return null as string | null;

    // ËÆ∞ÂΩïÁä∂ÊÄÅ
    const originalBg = canvas.backgroundColor as string | undefined;
    const objs = canvas.getObjects();
    const imageObjs: fabric.FabricObject[] = [];
    objs.forEach(o => { if ((o as any).type === 'image') imageObjs.push(o); });

    // ÈöêËóèÂõæÁâáÔºå‰ªÖ‰øùÁïôÁ∫øÊù°/Ë∑ØÂæÑÔºõËÉåÊôØËÆæÈÄèÊòé
    imageObjs.forEach(o => o.set('visible', false));
    canvas.backgroundColor = 'rgba(0,0,0,0)';
    canvas.renderAll();

    const dataURL = canvas.toDataURL({ format: 'png',multiplier:1 });

    // ËøòÂéü
    imageObjs.forEach(o => o.set('visible', true));
    canvas.backgroundColor = originalBg || '#ffffff';
    canvas.renderAll();

    return dataURL;
  }, []);

  const exportMaskImage = useCallback(() => {
    const canvas = fabricCanvasRef.current;
    if (!canvas || !isInitializedRef.current) return null as string | null;

    // ËÆ∞ÂΩïÁä∂ÊÄÅ
    const originalBg = canvas.backgroundColor as string | undefined;
    const objs = canvas.getObjects();
    const imageObjs: fabric.FabricObject[] = [];
    const nonImageObjs: fabric.FabricObject[] = [];
    const backupStyles = new Map<fabric.FabricObject, any>();
    objs.forEach(o => {
      if ((o as any).type === 'image') imageObjs.push(o);
      else nonImageObjs.push(o);
    });

    // ÈöêËóèÂõæÁâáÔºõÊääÂÖ∂‰ΩôË∑ØÂæÑ/ÂΩ¢Áä∂Êîπ‰∏∫ÁôΩËâ≤ÔºõËÉåÊôØËÆæÈªëËâ≤
    imageObjs.forEach(o => o.set('visible', false));
    nonImageObjs.forEach(o => {
      backupStyles.set(o, {
        stroke: (o as any).stroke,
        fill: (o as any).fill,
        opacity: (o as any).opacity
      });
      (o as any).stroke = '#ffffff';
      if ((o as any).fill) (o as any).fill = '#ffffff';
      (o as any).opacity = 1;
    });
    canvas.backgroundColor = '#000000';
    canvas.renderAll();

    const dataURL = canvas.toDataURL({ format: 'png',multiplier:1 });

    // ËøòÂéü
    nonImageObjs.forEach(o => {
      const b = backupStyles.get(o) || {};
      (o as any).stroke = b.stroke;
      (o as any).fill = b.fill;
      (o as any).opacity = b.opacity;
    });
    imageObjs.forEach(o => o.set('visible', true));
    canvas.backgroundColor = originalBg || '#ffffff';
    canvas.renderAll();

    return dataURL;
  }, []);

  // === ÂõæÂ±Ç/ÂØπË±°ÁÆ°ÁêÜÔºàÈíàÂØπÂõæÁâáÂØπË±°Ôºâ ===
  const listImageLayers = useCallback(() => {
    const canvas = fabricCanvasRef.current;
    if (!canvas || !isInitializedRef.current) return [] as Array<{
      id: string; name: string; visible: boolean; locked: boolean; zIndex: number;
    }>;

    const objects = canvas.getObjects();
    return objects
      .map((obj, index) => ({ obj, index }))
      .filter(({ obj }) => (obj as any).type === 'image')
      .map(({ obj, index }) => ({
        id: (obj as any).layerId || `image_${index}`,
        name: (obj as any).layerName || 'ÂõæÁâáÂõæÂ±Ç',
        visible: obj.visible ?? true,
        locked: !!(obj as any).lockMovementX || !!(obj as any).lockMovementY,
        zIndex: index,
      }));
  }, []);

  const findImageById = (id: string) => {
    const canvas = fabricCanvasRef.current;
    if (!canvas || !isInitializedRef.current) return null as fabric.FabricImage | null;
    const objects = canvas.getObjects();
    for (const obj of objects) {
      if (((obj as any).type === 'image') && ((obj as any).layerId === id)) {
        return obj as fabric.FabricImage;
      }
    }
    return null;
  };

  const setLayerVisibility = useCallback((id: string, visible: boolean) => {
    const img = findImageById(id);
    if (!img) return;
    img.set('visible', visible);
    fabricCanvasRef.current?.renderAll();
  }, []);

  const setLayerLocked = useCallback((id: string, locked: boolean) => {
    const img = findImageById(id);
    if (!img) return;
    (img as any).lockMovementX = locked;
    (img as any).lockMovementY = locked;
    (img as any).selectable = !locked;
    (img as any).evented = !locked;
    fabricCanvasRef.current?.renderAll();
  }, []);

  const removeLayer = useCallback((id: string) => {
    const img = findImageById(id);
    if (!img) return;
    fabricCanvasRef.current?.remove(img);
    fabricCanvasRef.current?.renderAll();
  }, []);

  const bringForward = useCallback((id: string) => {
    const img = findImageById(id);
    if (!img) return;
    fabricCanvasRef.current?.bringForward(img);
    fabricCanvasRef.current?.renderAll();
  }, []);

  const sendBackwards = useCallback((id: string) => {
    const img = findImageById(id);
    if (!img) return;
    fabricCanvasRef.current?.sendBackwards(img);
    fabricCanvasRef.current?.renderAll();
  }, []);

  const bringToFront = useCallback((id: string) => {
    const img = findImageById(id);
    if (!img) return;
    //fabricCanvasRef.current?.bringToFront(img);
    (fabricCanvasRef.current as any)?.bringToFront(img);
    fabricCanvasRef.current?.renderAll();
  }, []);

  const sendToBack = useCallback((id: string) => {
    const img = findImageById(id);
    if (!img) return;
    fabricCanvasRef.current?.sendToBack(img);
    fabricCanvasRef.current?.renderAll();
  }, []);

  const selectLayer = useCallback((id: string) => {
    const img = findImageById(id);
    if (!img) return;
    fabricCanvasRef.current?.setActiveObject(img);
    fabricCanvasRef.current?.renderAll();
  }, []);

  // Âä†ËΩΩÁîªÂ∏ÉÊï∞ÊçÆ
  const loadCanvasData = useCallback((data: string | object) => {
    const canvas = fabricCanvasRef.current;
    if (!canvas || !isInitializedRef.current) return;

    canvas.loadFromJSON(data, () => {
      canvas.renderAll();
    });
  }, []);

  // Âä†ËΩΩÂõæÁâá‰Ωú‰∏∫ÂØπË±°ÔºàÂõæÂ±ÇÔºâ
  const loadImageAsObject = useCallback((imageUrl: string) => {
    const canvas = fabricCanvasRef.current;
    if (!canvas || !isInitializedRef.current) return;

    fabric.FabricImage.fromURL(imageUrl, {
      crossOrigin: 'anonymous'
    }).then((img) => {
      const cW = canvas.getWidth();
      const cH = canvas.getHeight();
      const iW = img.width || 1;
      const iH = img.height || 1;

      // ÈÄÇÂΩìÁº©ÊîæÔºö‰∏çË∂ÖËøáÁîªÂ∏ÉÁöÑ 75%
      const scale = Math.min((cW / iW) * 0.75, (cH / iH) * 0.75, 1);
      img.scale(scale);

      // Â±Ö‰∏≠ÊîæÁΩÆ
      img.set({
        left: (cW - (img.width || 0) * (img.scaleX || 1)) / 2,
        top: (cH - (img.height || 0) * (img.scaleY || 1)) / 2,
      });

      // ÂàÜÈÖçÂõæÂ±ÇÂÖÉÊï∞ÊçÆÔºå‰æø‰∫éÂõæÂ±ÇÈù¢ÊùøÁÆ°ÁêÜ
      (img as any).layerId = `layer_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
      (img as any).layerName = 'ÂõæÁâáÂõæÂ±Ç';

      canvas.add(img);
      canvas.setActiveObject(img);
      canvas.renderAll();

      // ÂëäÁü•Â§ñÈÉ®‚ÄúÂØπË±°Â∑≤Ê∑ªÂä†‚ÄùÔºå‰æø‰∫éÂà∑Êñ∞Â±ÇÂàóË°®/ÂØºÂá∫
      onObjectAddedRef.current?.(img);
    }).catch((error) => {
      console.error('Âä†ËΩΩÂõæÁâáÂØπË±°Â§±Ë¥•:', error);
    });
  }, []);

  return {
    canvasElementRef,
    fabricCanvas: fabricCanvasRef.current,
    isInitialized: isInitializedRef.current,
    updateBrush,
    setSelectMode,
    clearCanvas,
    getCanvasData,
    getCanvasImage,
    hasCanvasContent,
    loadCanvasData,
    // Êñ∞ÔºöÂØπË±°ÊñπÂºèÂä†ËΩΩÔºàÊé®ËçêÔºâ
    loadImageAsObject,
    // ÂÖºÂÆπÂà´ÂêçÔºö‰øùÊåÅÊóßÂêçÁß∞‰ΩÜË°å‰∏∫Á≠âÂêå‰∫éÂØπË±°Âä†ËΩΩ
    loadImageAsBackground: loadImageAsObject,
    // ÂõæÂ±ÇÂ∑•ÂÖ∑
    listImageLayers,
    setLayerVisibility,
    setLayerLocked,
    removeLayer,
    bringForward,
    sendBackwards,
    bringToFront,
    sendToBack,
    selectLayer,
    // ÂØºÂá∫Â∑•ÂÖ∑
    exportPoseImage,
    exportMaskImage
  };
}
